package applications.homeworks;

//change this to point to student package
import static applications.homeworks.unlocked.hw1.MotionPlanner.AlgorithmType.*;
import applications.homeworks.unlocked.hw1.*;
//import static applications.homeworks.locked.hw1.MotionPlanner.AlgorithmType.*;
//import applications.homeworks.locked.hw1.*;

import javax.swing.*;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.util.*;

import smrde.*;
import smrde.gui.*;
import smrde.gui.DrawingAreaEventConsolidator.EntryMode;
import smrde.math.*;
import smrde.util.*;
import smrde.systems.*;
import smrde.objects.*;
/**
 * An application to perform motion planning in a simulated world of obstacles. Obstacles are
 * generated by a random number generator and they are represented as Java Shapes. Likewise, the
 * Shape which surrounds the robot is used for collision detection purposes. The robot is circular
 * and hence the search space is a 2D workspace grid which discretizes a rectangular region.
 * 
 * The program is structured like others in this series. It is intended to test an instance of
 * motionPlanner. This class has a method called doIteration which is intended to permit seeing
 * what is happening while it is solving a planning query. It will return after a specified number
 * of state expansions so that the user can draw the new states that have been expanded and
 * see how the search is proceeding. doHorizonDrawing is the switch which, when on, will cause
 * the horizon cells to be drawn on screen as the search proceeds.
 * 
 * After some number of expansions, the planner will either find the goal or fail. 
 * 
 * NUM_OBSTACLES is used to set the number of obstacles in the world rectangle. This number
 * will be generated and they will not overlap.
 * 
 * Two forms of limited horizon search are possible. If you set sensorRadius to a sufficiently small 
 * number, the planner will be unable to see obstacles beyond this radius. If you set maxExpansions,
 * the planner will terminate its search after this number of expansions has been computed.
 * 
 * If your computer is slow, you may tweak a few numbers to simplfy the problem and make your coding 
 * efficient. The easiest way to make the problem computationally easier is to increase USER_DS by a 
 * factor of 2 or 4. You will eventually have to reduce the number of obstacles and/or the size of 
 * the robot if you do this.
 * 
 * You might want to reduce the number of obstacles during your debugging phase anyway. It may be
 * worthwhile to try different integers in the constructor for ranGen to get a world which
 * tests the case you are interested in. Then you can test it over and over until you fix any
 * problems. A simplere way is to turn off makeRandomWorld and alter the code for the repeatable 
 * world or use the mouse to make the world you want.
 * 
 * To quickly understand this code:
 * 
 * Find every reference to the variable motionPlannerContext in this file and see how it is used. It is
 * created inside start() and the planning query (start and goal poses) is also generated there.
 * Inside stepApplication() notice that a state machine is being executed which is controlled by the
 * variables planningPath and executingPath. motionPlanner.doIteration() is called until it either 
 * fails or the plan is ready. If doHorizonDrawing is set, it will expand only minExpansions nodes
 * and update the graphics. The MotionPlanner provdes access to sets of states which are to be drawn 
 * for various reasons. If planning succeeds and doExecutePlan is on, the plan is extracted and 
 * the top level application state machine transitions to plan execution mode. In this mode, 
 * the last plan is removed from the screen, the new plan is drawn, the robot is moved one step 
 * along the new plan, and a new planner query is set up which starts at the present state and 
 * tries once again to plan toward the same goal state. After this query is set up, the mode 
 * transitions back to planning again and the cycle repeats. This plan-execute cycle continues
 * until either a) the goal is reached  b) the planner fails (open list is empty so horizon 
 * cannot be expanded any more) c) the user terminates due to issues such as nonconvergence.
 * 
 * @author alonzo
 *
 */
public class ApplicationHW1MotionPlanner implements Appable,ActionListener,DrawingAreaEventHandler {
	/**
	 * The window in which this application is to live.
	 */
	JFrame parentJFrame;
	/**
	 * Drawing area for ground truth simulator.
	 */
	DrawingArea	simDrawingPanel;
	/**
	 * Drawing area for motion planner state.
	 */
	DrawingArea			appDrawingPanel;
	/**
	 * User interface GUI widgets.
	 */
	ControlPanelBasic	controlPanel;
	/**
	 * User interface GUI widgets.
	 */
	ControlPanel 		controlPanel2;
	/**
	 * The simulated (ground truth) world and GUI objects
	 */
	WorldEngine     simWorldEngine;
	/**
	 * The application (planner) world and GUI objects.
	 */
	WorldEngine     appWorldEngine;
	/**
	 * Width and height of rectangle in the world which bounds the start and goal.
	 */
	final double USER_SIZE  = 15.0; // 40.0
	/**
	 * Width and height of the drawing area in pixels. Adjiust this if your windows are too big
	 * or too small on your screen.
	 */
	final int PANEL_SIZE = 500; // 700 for external screen, 500 for laptop
	/**
	 * The spatial discretization which is used for the search space. This has a massive 
	 * effect on runtime performance.
	 */
	double USER_DS = 0.5; //0.5 runs fast, 0.2 runs slow
	/**
	 * The cost of an obstacle cell.
	 */
	double OBS_COST = 1000.0; 
	/**
	 * Number of obstacles desired. The obstacle generator will continue to search for locations for these 
	 * until this many are generated and they do not overlap. If you ask for too many you will
	 * create an infinite loop
	 */
	final int NUM_OBSTACLES = 10; //40
	/**
	 * Radius of obstacles in user units.
	 */
	final double OBSTACLE_RADIUS = 1.0; // 2.5
	/**
	 * Number of vertices in all obstacles.
	 */
	final int OBSTACLE_VERTICES = 6;
	/*
	 * Colors for obstacles
	 */
	final Color obstacleColor = PredefinedColor.Tan;
	final Color robotColor = PredefinedColor.Goldenrod;
	final Color floorColor = PredefinedColor.GreenishBrown;
	final Color pathColor = PredefinedColor.Brown;
	
	final Color goalColor = Color.red;
	final Color startColor = Color.green;
	
	final Color closedColor = Color.green;
	final Color openColor = Color.red;
	final Color changedColor = Color.blue;
	final Color markedColor = Color.black;
	
	/*
	 * Colors for obstacles. Use these for monochrome display in order to get 
	 * black and white imagery for documentation.
	 */
//	final Color obstacleColor = PredefinedColor.Grey5;
//	final Color robotColor = PredefinedColor.Goldenrod;
//	final Color floorColor = PredefinedColor.Grey7;
//	final Color pathColor = PredefinedColor.Brown;
//	
//	final Color goalColor = PredefinedColor.Grey5;
//	final Color startColor = PredefinedColor.Grey5;
//	
//	final Color closedColor = PredefinedColor.Grey4;
//	final Color openColor = PredefinedColor.Grey4;
//	final Color changedColor = PredefinedColor.Grey0;
//	final Color markedColor = PredefinedColor.Grey0;
	/**
	 * The simulated world. Contains robot and obstacles.
	 */
	World simWorld;
	/**
	 * The application world. Contains cost map image and backpointer arrows.
	 */
	World appWorld;
	/**
	 * Random number generator used to produce random worlds. You can create it 
	 * with or without a seed. If you use the same seed twice, you get the same
	 * world over again but the world you get also depends on other settings like 
	 * USER_DS, NUM_OBSTACLES, OBSTACLE_RADIUS, OBSTACLE_VERTICES and probably more.
	 */
//	Random ranGen = new Random(10);
	Random ranGen = new Random();
	/**
	 * Total time latest search tree has been on screen.
	 */
	double searchTreeRenderTime;
	/**
	 * Minimum time search tree is to remain onscreen. Used to make sure it does not
	 * appear and disappear so fast it is not seen.
	 */
	final double searchTreeDisplayTimeInMillis = 100.0; //100.0;
	/**
	 * Instance of motionPlanner used to solve all queries.
	 */
	MotionPlannerContext motionPlannerContext;
	//MotionPlannerContext motionPlannerContext;
	/**
	 * Perception simulator used to look in map and provide cell costs within a radius of the
	 * robot.
	 */
	MotionPlannerPerceptionSimulator perceptionSimulator;
	//MotionPlannerPerceptionSimulator perceptionSimulator;
	/**
	 * Cost map 
	 */
	MotionPlannerCostMap costMap;
	//MotionPlannerCostMap costMap;
	/**
	 * Choice of motion planner algorithm.
	 */
	MotionPlanner.AlgorithmType algorithm;	
	{
// 	  algorithm = Grassfire;
	  algorithm = Dykstra;
// 	  algorithm = Astar;
//	  algorithm = Dstar;
	}
	/**
	 * Make a random world or use a hardcoded one.
	 */
	boolean makeRandomWorld = false;
	/**
	 * Switch to control whether plan is executed or not.
	 */
	boolean executePlan = true;
    /**
     * Turn on doNavFunction if you want to see the entire nav function computed. The planning
     * should work correctly in either case.
     */
	boolean doNavFunction = false;
	{
	 	/**
	 	 * Dstar works best if an up front navigation function is computed
	 	 * but thereafter, it is wasteful, so it is turned off.
	 	 */
		if(algorithm == Dstar) doNavFunction = false;
	}
	/**
	 * States have 8 neighbours if on, 4 if off.
	 */
	boolean do8ConnectedTopology = true; // do 4 if false.
	/**
	 * Use manhattan definition of distance if on. Euclidean if off. 
	 */
	boolean doManhattanMetric = true; // Euclidean if false
	/**
	 * Controls the greediness of search.
	 */
	double  greedyFactor = 1.0;
	/**
	 * Makes Dstar run from start to goal (same as Astar) for debugging purposes.
	 */
	boolean doReverseDstar = false;
	/**
	 * Switch to control whether the cost map image is drawn on screen.
	 */
	boolean doCostMapDrawing = true;
	/**
	 * Maximum number of expansions permitted to try to solve the planning query. If you want to 
	 * do limited horizon planning, 200 is roughly right. If you want to plan right to the finish,
	 * set this to 30000 or so.
	 */
//	int maxExpansions = 200;
//	int maxExpansions = 50;
	int maxExpansions = 30000;
	/**
	 * Minimum number of expansions permitted before returning from doIteration. Controls how
	 * often the rendering is updated to include the newly expanded cells. This can be set as low 
	 * as 1 and used with breakpoints if you want to examine what is happening very closely.
	 * This field has no effect when doHorizonDrawing is off.
	 */
	int minExpansions = 1;
//	int minExpansions = 200;
//	int minExpansions = 4500;
	/**
	 * Cell counter of the application. Useful for determining the distance travelled to the 
	 * goal.
	 */
	int cellsTraversed;
	/**
	 * State variable used to control planning mode. Cleared when path 
	 * has been determined.
	 */
	boolean planningPath;
	/**
	 * State variable used to control execution mode. Set when path
	 * is being executed.
	 */
	boolean executingPath;
	/**
	 * Switch to control whether expanded cells are drawn on screen.
	 */
	boolean doHorizonDrawing = true;
	/**
	 * Switch to control whether the path is drawn on screen.
	 */
	boolean doPathDrawing = true;
	/**
	 * Switch to control whether node costs [g() values] or edge costs 
	 * [c(s1,s2)] are drawn.
	 */
	boolean drawNodeCosts = false;
	/**
	 * Length of steps to take along path when executing it. Set to higher than 0 if you want 
	 * the robot to move faster.
	 */
	int pathExecutionStateSkips = 0;
	/**
	 * Size of circular robot used. Need not be the same as the cell size. If you set it very 
	 * small if really slows things down due to collision detection calculations in the simulator.
	 */
	final double robotRadius = USER_DS*2;  // too small slows things alot due to MinDs in InertialContext
	/**
	 * Maximum radius at which obstacles can be seen. This radius is defined in C Space
	 * where the robot radius is already included in the obstacles. Hence, this number means the
	 * distance, measured past the edge of the robot, that the sensor can see.
	 * 
	 * This is only has an effect for Dstar.
	 */
	final double DStarSensorRadius = 2.0; // robot radius is already included since cost map is CSpace.
	/**
	 * Rectangle enclosing the world where start, goal, and all obstacles will go.
	 */
	Rectangle2D worldRect;
	/**
	 * Start pose for the planning query
	 */
	Pose2D startPose;
	/**
	 * Goal pose for the planning query
	 */
	Pose2D goalPose;
	/**
	 * Cycle counter of the application. Useful for setting breakpoints at
	 * certain cycles.
	 */
	int cycle = 0;
	/**
	 * Sprite for drawing robot executing path.
	 */
	Sprite robotSprite;
	/**
	 * Sprite for drawing robot in C Space
	 */
	Sprite robotCSpaceSprite;
	/**
	 * Sprite for drawing a background color in a filled rectangle
	 */
	Sprite floor;
	/**
	 * Sprite for drawing the start state
	 */
	Sprite startSprite;
	/**
	 * Sprite for drawinfg the goal state
	 */
	Sprite goalSprite;
	/**
	 * Sprites for drawing the search tree.
	 */
	RectangleMapField<Sprite> arrowSprites;
	/**
	 * A grayscale image used to render the cost map.
	 */
	ImageSpriteImage costImage;
	/**
	 * Sprite containing hte cost map image.
	 */
	ImageSprite costImageSprite;
	/**
	 * Interface to control panel to permit pausing application.
	 */
	boolean iAmActive = false;
	
	/**
	 * Obstacle Panel
	 */
	ObstacleField obstacleField;
	/*
	 *********************************** Application Setup ***********************************
	 */
	/**
	 * Constructs an Application whose GUI is contained within the parent JFrame.
	 * 
	 * @param frame the parent JFrame.
	 */
	public ApplicationHW1MotionPlanner(JFrame frame){
		parentJFrame = frame;
	}
	/*
	 *********************************** Appable Interface ***********************************
	 */
    /**
     * Create the GUI.
     */
    public void createGUI(){    	    
        // Create a graphics panel
        simDrawingPanel = new DrawingArea(PANEL_SIZE,PANEL_SIZE,
        		USER_SIZE,USER_SIZE,new Pose2D(0.0,0.0,0.0),"Simulation Drawing Area");
        
        // Make an obstacle field that listens for mouse clicks to add or delete
        // obstacles;
        obstacleField = new ObstacleField(simDrawingPanel, OBSTACLE_RADIUS, OBSTACLE_VERTICES, obstacleColor);
        
        obstacleField.setDiscretization(true);
        
        parentJFrame.add(simDrawingPanel,new GBConstraints(1,0,3,3));
        
        // Create another graphics panel
        appDrawingPanel = new DrawingArea(PANEL_SIZE,PANEL_SIZE,
        		USER_SIZE,USER_SIZE,new Pose2D(0.0,0.0,0.0),"Application Drawing Area");
        
        parentJFrame.add(appDrawingPanel,new GBConstraints(4,0,3,3));
        appDrawingPanel.addEventListener(this);
        // Create a control panel
        controlPanel = new ControlPanelBasic(PANEL_SIZE*2,PANEL_SIZE/3,"Application Control Panel"); 
        makeControlPanel();
        parentJFrame.add(controlPanel,new GBConstraints(1,3,6,1));
        
        // Create a control panel
        controlPanel2 = new ControlPanel(this,appDrawingPanel,
        		200,400,"Screen Capture"); 
        
        // Add some predefinedButtons
        controlPanel2.addPredefinedButtons(new String[]
               {"ScreenCapture"});
        controlPanel.add(controlPanel2);
  	
    	// Fix the window layout and redraw
        parentJFrame.pack();
    }
    
    /**
     * Destroy the GUI
     */
    public void destroyGUI() {
        parentJFrame.remove(simDrawingPanel);
        parentJFrame.remove(appDrawingPanel);
        parentJFrame.remove(controlPanel);
        parentJFrame.remove(instructionPanel);
        parentJFrame.pack();
    }
    /**
     * Initialize the application. Create the World and a display list for its
     * rendering.
     */
    public void startOrReset() {
		
		// Create simulation objects and graphics for them.
		simWorldEngine = new WorldEngine();
		createSimulationWorld();
		simDrawingPanel.setDisplayList(simWorld);	
    	obstacleField.acquireObstacles();
		
		// Create application objects and graphics for them.
		appWorldEngine = new WorldEngine();
		createApplicationWorld();
		appDrawingPanel.setDisplayList(appWorld);	
		
		// Get graphics thread to draw this
		simDrawingPanel.repaint();
		appDrawingPanel.repaint();
		
		// Set up application state machine to plan a path when started
		planningPath = true;
    }
    
    /**
     * Shut down the application. Undo everything that was done in start().
     */
    public void stop() {
    	simWorld = null;
    	appWorld = null;	
    }
    /**
     * Execute one step of the application. This routine should run in a fraction of a second in
     * order to respond in a timely manner to a request to stop the application.
     * It should create worker threads to do any work that cannot be accomplished in
     * such an amount of time.
     */
    public boolean step() {
		
    	stepWorld();
		simDrawingPanel.repaint();
		appDrawingPanel.repaint();
		
		return true;
    }
 
    /**
     * Move the simulation and the application forward by one cycle.
     *
     */
	void stepWorld(){
		
		if(!iAmActive) {Sleeper.sleep(200); return; }
		
		stepSimulation();
		stepApplication();
		
		Sleeper.sleep(20); // just to slow down the graphics
		
		cycle++;
	}
	
	/*
	 *********************************** Create Simulation ***********************************
	 */

    /**
     * Create a graphics display list for the simulation to report graphically.
     * @return
     */
    void createSimulationWorld() {
		
		simWorld = new World("SimList");

		// Put a floor in it
    	Rectangle2D floorRect = new Rectangle2D.Double(-USER_SIZE/2.0,-USER_SIZE/2.0,
    			USER_SIZE,USER_SIZE);
    	Pose2D floorPose = new Pose2D();
		floor = new Sprite("floor",floorRect,floorPose);		
		floor.drawingContext().setFillColor(floorColor);
		//floor.drawingContext().setStroke(new BasicStroke((float)0.2));
		floor.drawingContext().setDoDrawBorder(false);
		simWorld.add(floor);
		
		//ranGen = new Random();
    	worldRect = new Rectangle2D.Double(-USER_SIZE/2.0,-USER_SIZE/2.0,
    			USER_SIZE,USER_SIZE);
    	
		// Create a robot sprite for drawing the execution of the path		
		robotSprite = Sprite.CircleSprite("Robot", robotRadius,0.0,0.0,0.0);
		robotSprite.drawingContext().setFillColor(robotColor);
		robotSprite.drawingContext().setDoDrawBorder(false);
		robotSprite.drawingContext().setDoDrawFill(false);
		simWorld.add(robotSprite);
		
		// Create the prior obstacles in the world.
		makeObstacleField();
    }
    
    /**
     * Create a field of obstacles in the world. Make NUM_OBSTACLES ones in 
     * random positions if makeRandomWorld is on. Make a hardcoded world if 
     * it is off.
     *
     */
    private void makeObstacleField(){
    	int numInitialObstacles;
    	
    	if(makeRandomWorld){
    		numInitialObstacles = NUM_OBSTACLES;
    		
        	new ObstacleWorld(numInitialObstacles,
    				OBSTACLE_VERTICES, OBSTACLE_RADIUS,simWorld,worldRect,ranGen,
    				false,obstacleColor);
    	} else {
    		numInitialObstacles = 0;
    		double xo=0.0,yo=0.0;
    		RigidBodySprite obs = obstacleField.makeObstacle(xo,yo,0.0);
    		// Comment the following lione out if you want an empty nonrandom world
    		simWorld.add(obs);
    	}

    }
	
	/*
	 ***************************** Create Application and Planning Query ************************
	 */
    
    /**
     * Create the motion planner and supporting objects.
     */
    void createApplicationWorld() {
		
		appWorld = new World("AppList");

		// Create motion planner. The body that it is given is for its internal use
		// for testing for collisions. The planner will change the internal state
		// of the body so it cannot be a reference to the real robot. It must instead
		// be an object of the same shape.
		Sprite bodySprite = Sprite.CircleSprite("Body", robotRadius,0.0,0.0,0.0);
		RigidBodySprite body = new RigidBodySprite(bodySprite);
		bodySprite.drawingContext().setFillColor(robotColor);
		
		// set up sensor radius to be finite for Dstar when executing
		double sensorRad;
		if(algorithm != Dstar)
			sensorRad = Double.MAX_VALUE;
		// Dstar vision is only reduced when executing. This is done to permit 
		// a comparison with an A* navigation function in the homework.
		else if(executePlan){
			sensorRad = DStarSensorRadius;
		}
		else
			sensorRad = Double.MAX_VALUE;
		
		// Create the motion planner
		motionPlannerContext = new MotionPlannerContext(body, robotSprite.poseContext().poseRelative, sensorRad,
				simWorld, worldRect, OBS_COST, USER_DS, maxExpansions, 
				algorithm, doNavFunction, do8ConnectedTopology, doManhattanMetric, greedyFactor);
		//motionPlanner = new MotionPlanner(body, appList, plannerRect);
		
		// Create a random motion planning query (a start and goal state)
		if(!(makeQuery())){
			System.out.printf("World Creation Failed\n");
			stop();
		}
		
		// Now that start is known, put the robot there.
		robotSprite.poseContext().setPoseRelative(startPose);
		
		// Put a cost map image in the window
		Pose2D sensorPose = robotSprite.poseContext().poseRelative;
    	costMap = motionPlannerContext.costMap;
		perceptionSimulator = new MotionPlannerPerceptionSimulator(costMap,sensorPose, DStarSensorRadius);

		// Create two rectangles for use as the start and goal markers.
		startSprite = Sprite.RectangleSprite("Start", USER_DS,USER_DS,0.0,0.0,0.0);
		motionPlannerContext.searchGraph.trimToNearestDiscreteStatePose(startPose);
		startSprite.poseContext().setPoseWorld(startPose);
		startSprite.drawingContext().setFillColor(startColor);
		simWorld.add(startSprite);

		goalSprite = Sprite.RectangleSprite("Goal", USER_DS,USER_DS,0.0,0.0,0.0);
		motionPlannerContext.searchGraph.trimToNearestDiscreteStatePose(goalPose);
		goalSprite.poseContext().setPoseWorld(goalPose);
		goalSprite.drawingContext().setFillColor(goalColor);
		simWorld.add(goalSprite);
		
		// This line is used to make sure clicked obstacles appear underneath the
		// arrow field on screen
        obstacleField.setLastObject(startSprite);
		
		// Create a grayscale image for rendering the cost field.
		if(doCostMapDrawing){
			costImage = new ImageSpriteImage(costMap.costArray.cols,costMap.costArray.rows);
			costImageSprite = new ImageSprite("CostMapImage",worldRect, costImage, new Pose2D(0.0,0.0,Math.PI/2.0));
			appWorld.add(costImageSprite);
			// Update image contents
			for(int i=0 ; i<costMap.costArray.rows; i++){
				for(int j=0 ; j < costMap.costArray.cols; j++){
					updateCostCellPixel(i,j);
				}
			}
		}

		// Create an array of arrow sprites for rendering backpointers
		arrowSprites = new RectangleMapField<Sprite>(worldRect,USER_DS);
		for(int i=0 ; i<arrowSprites.rows; i++){
			for(int j=0 ; j < arrowSprites.cols; j++){				
				Sprite sprite = Sprite.ArrowSprite("SearchElement",0.9*USER_DS,0.0,0.0,0.0);
				sprite.drawingContext().setDoDrawBorder(false);
		    	arrowSprites.setCellValueCell(new Point(i,j),sprite);
				appWorld.add(sprite);
				
			}
		}	
		
		// Create a robot sprite for drawing the execution of the path		
		robotCSpaceSprite = Sprite.CircleSprite("RobotCSpace", USER_DS/2.0,0.0,0.0,0.0);
		robotCSpaceSprite.drawingContext().setFillColor(robotColor);
		robotCSpaceSprite.drawingContext().setDoDrawBorder(false);
		robotCSpaceSprite.drawingContext().setDoDrawFill(false);
		appWorld.add(robotCSpaceSprite);
		
		// Do first Dstar iteration
		doFirstDstarIteration();
    }  
    
    /**
     * Create planning query. Make sure the start and goal are well separated
     * and that neither the start nor the goal are in collision.
     */
    private boolean makeQuery(){
    	int iterations = 0;
    	if(makeRandomWorld) {
			while(iterations < 200){
				Point2D startPoint = Util.randomPointInRectangle(ranGen,worldRect);
				startPose = new Pose2D(startPoint,0.0);
				
				Point2D goalPoint  = Util.randomPointInRectangle(ranGen,worldRect);
				goalPose = new Pose2D(goalPoint,0.0);
				
				if(Pose2D.hypot(startPose,goalPose) > 0.8*USER_SIZE && checkQuery(startPose,goalPose)) {
					setQuery(startPose,goalPose);
					return true;
				}
				
				iterations++;
			}
    	} else {

    		double xs,ys;
    		double xg,yg;
    		
    		xs = worldRect.getMinX()+worldRect.getWidth() * 0.1;
    		ys = worldRect.getMinY()+worldRect.getHeight()* 0.1;
    		xg = worldRect.getMinX()+worldRect.getWidth() * 0.9;
    		yg = worldRect.getMinY()+worldRect.getHeight()* 0.9;
    		
    		startPose = new Pose2D(xs,ys,0.0);
    		goalPose  = new Pose2D(xg,yg,0.0);
    		
    		if(checkQuery(startPose,goalPose)) {
    			setQuery(startPose,goalPose);
    			return true;
    		}
    	}
    	
    	return false;
    }

    
    /**
     * Check the start and goal of the motion planning query for collisions. Reverse their 
     * roles in the case of Dstar.
     * @param start start state
     * @param goal goal state
     * @return
     */
    boolean checkQuery(Pose2D start, Pose2D goal){
    	boolean result;
    	if(!motionPlannerContext.motionPlanner.doingDStar())
    		result = motionPlannerContext.motionPlanner.checkQuery(start,goal);
    	else
	    	result = motionPlannerContext.motionPlanner.checkQuery(goal,start);
    	return result;
    }
    
    /**
     * Configure the planner to run all over again on a new start and the 
     * old goal.
     * @param state the new start state
     */
    void setQueryFromNewStart(MotionPlannerState startState){
		// set up for replanning all over again
		Pose2D newStart = new Pose2D(startState.x(),startState.y(),0.0);
		if(!(motionPlannerContext.motionPlanner.doingDStar()))
			setQuery(newStart,goalPose);
		else{
			boolean success = motionPlannerContext.motionPlanner.moveGoal(new Point2D.Double(newStart.getX(),newStart.getY()));
			if(!success){
				System.out.printf("Robot drove onto obstacle\n");
				executingPath = false;
			}
		}
		// Move the robot to the new state and
		// put the state machine back in planning mode.
		setRobotPose(newStart);
		planningPath = true;
    }
    
    /**
     * Set the start and goal of the motion planning query. Reverse their roles in the 
     * case of Dstar.
     * @param start start state pose
     * @param goal goal state pose
     * @return
     */
    boolean setQuery(Pose2D start, Pose2D goal){
    	boolean result;
    	if(!motionPlannerContext.motionPlanner.doingDStar() || doReverseDstar)
    		result = motionPlannerContext.motionPlanner.setQuery(start,goal);
    	else
	    	result = motionPlannerContext.motionPlanner.setQuery(goal,start);
    	
    	cellsTraversed = 0;
    	
    	return result;
    }
    
    void setRobotPose(Pose2D pose){
		robotSprite.poseContext().setPoseRelative(pose);
		robotCSpaceSprite.poseContext().setPoseRelative(pose);
		startSprite.poseContext().setPoseRelative(pose);
    }
	
	/*
	 *********************************** Execute Simulation ************************************
	 */

    /**
     * Update the cost map to reflect any changes to obstacles performed in the GUI or
     * any portions of obstcles that are newly in view. Have Dstar update its search tree
     * if there is anything to update. Update the cost map display if any costs changed.
     */
    void stepSimulation(){
    	
    	// process any map updates
    	boolean obstaclesChanged = obstacleField.obstaclesCreated.size() != 0;
    	obstaclesChanged = obstaclesChanged || obstacleField.obstaclesDeleted.size() != 0;
		if(obstaclesChanged){
			motionPlannerContext.costMap.processObstacles(
					obstacleField.obstaclesCreated,obstacleField.obstaclesDeleted);
			obstacleField.obstaclesCreated.clear();
			obstacleField.obstaclesDeleted.clear();
			planningPath = true; // force an immediate replan
		}
				
		// Process any map updates in Dstar if doing Dstar
		motionPlannerContext.motionPlanner.updateDstarSearchTreeForMapChanges();
		
		// update cost map graphics for modified cells.
		for(Point2D pt : motionPlannerContext.costMap.cellsModified){
			Point2D ptCell = motionPlannerContext.costMap.costArray.inRectToOutRect(pt);
			int i = (int) ptCell.getX();
			int j = (int) ptCell.getY();			
			updateCostCellPixel(i,j);
		}
		motionPlannerContext.costMap.cellsModified.clear();
		
		// If doing perception, See if any more cost map is in view.
		if(algorithm == Dstar && executePlan)
			perceptionSimulator.simulatePerception();
		
		// Process any perception updates in Dstar if doing Dstar
		motionPlannerContext.motionPlanner.updateDstarSearchTreeForPerceivedCosts();
		
		// update cost map graphics for seen cells.
		for(Point2D pt : motionPlannerContext.costMap.cellsSeen){
			Point2D ptCell = motionPlannerContext.costMap.costArray.inRectToOutRect(pt);
			int i = (int) ptCell.getX();
			int j = (int) ptCell.getY();			
			updateCostCellPixel(i,j);
		}
		motionPlannerContext.costMap.cellsSeen.clear();
    }
	
	/*
	 *********************************** Execute Application ************************************
	 */
    
    /**
     * Create the navigation function that DStar starts out with.
     */
    void doFirstDstarIteration(){
		// Do first Dstar iteration
		if(motionPlannerContext.motionPlanner.doingDStar()){
			motionPlannerContext.motionPlanner.doIteration(maxExpansions,true);
			drawSearchTree();
			holdSearchTree();
			appDrawingPanel.repaint();
		}
    }
    /**
     * Execute the main state machine which continuously and incrementally replans the path
     * and then executes one step of it and starts the query all over when the goal is reached.
     */
    void stepApplication(){
    	
    	// Work incrementally on the plan and draw progress
    	if(planningPath){
        	int expansions = maxExpansions;
        	if(doHorizonDrawing) expansions = minExpansions;
    		motionPlannerContext.motionPlanner.doIteration(expansions,false);
    		checkForPlanningCompletion();
    		drawSearchTree();    		
    		
    		// Save cost status right after incremental drawing if doing Dstar
    		if((motionPlannerContext.motionPlanner.doingDStar())){
    			motionPlannerContext.searchGraph.recordCostsForChangeDetection();
        		holdSearchTree(); // keep results on screen
    		}
    	// Execute the path if execution is turned on and planning is done
    	} else if(executingPath){
    		holdSearchTree(); // keep results on screen
    		//erase search tree and old path
    		eraseSearchTree();
    		// update path on screen
    		eraseOldPath();
    		
    		MotionPlannerState state = executePath();
    		drawPath();
    		drawRobot(state);
    	}
    	// Come here if execution is turned off and planning is done
    	else{
    		holdSearchTree(); // keep results on screen
    		// Set up a new replanning cycle and save costs after
    		// final drawing if not doing Dstar
    		if(!(motionPlannerContext.motionPlanner.doingDStar())){
	        	motionPlannerContext.searchGraph.recordCostsForChangeDetection();
    		}
    		// Plan all over again. Dstar will remember what it knew of the cost map.
    		setQuery(startPose,goalPose);
    		setRobotPose(startPose);
    		if(motionPlannerContext.motionPlanner.doingDStar()){
    			doFirstDstarIteration();
    		}
    		planningPath = true; // plan over again
    	}
    }
    
    /**
     * Check conditions for transition to execution and replanning and
     * perform the transition if necessary.
     *
     */
    void checkForPlanningCompletion(){

		/**
		 * Announce failure on premature termination of iterations.
		 */
		if(motionPlannerContext.motionPlanner.planningFailed()){
			System.out.printf("Planner Failure!!\n");
			planningPath = false;
			executingPath = false;
			return;
		}
		/**
		 * Switch to execute mode if all required iterations are done
		 * in navFunction mode.
		 */
		if(doNavFunction && motionPlannerContext.motionPlanner.navReady()){
			motionPlannerContext.motionPlanner.extractPath();
			planningPath = false;
			executingPath = executePlan;
		}
		/**
		 * Switch to execute mode and extract path if path is ready in path mode.
		 */
		else if(!doNavFunction && motionPlannerContext.motionPlanner.pathReady()){
			motionPlannerContext.motionPlanner.extractPath();
    		planningPath = false;
    		executingPath = executePlan;
		}
    }
    
    /**
     * Execute the path by extracting states from the front.
     * @return the next state on the path. If the path is empty, planning has failed and 
     * the start state is returned
     */
    MotionPlannerState executePath(){
        /**
         * Returns the next state on the path. 
         */	
		MotionPlannerState state = motionPlannerContext.getStartState();
		
		ArrayList<MotionPlannerState> path = motionPlannerContext.motionPlanner.getPath();
			
		System.out.printf("Path size: %d\n",path.size());
		
		// Return present position if planning failed.
		if(path.size() == 0){
			return state; 
		}
		
		// Path is not empty. Present state is on the front. Remove it.
		state = path.remove(0);
		
		// If path is empty now, we are at the goal
		if(path.size() == 0){
			System.out.printf("Made it in %d cells!!\n",cellsTraversed);
			executingPath = false;
			return state;
		}
		
		// If the path still has elements in it try to perform any required skipping
		if(path.size() > 0){
			// Skip specified number iof they exist
			int steps = 0;
			while(steps < pathExecutionStateSkips && path.size() > 0){
				state = path.remove(0);
				cellsTraversed++;
				steps++;
			}
		}
		// If there are still more elements, grab the first one
		if(path.size() > 0){
			// grab first state on remaining path
			state = path.get(0);
			cellsTraversed++;
		}
		// Set up the query from the new start state
		setQueryFromNewStart(state);
		
		return state;
    }
    
	/*
	 ************************************** Draw  Graphics ************************************
	 */
    
    /**
     * Draws the search tree. 
     * 
     *      								Comments on State Sets
     * 
     * Processes the following sets of states:
     * 
     * statesTransient: States that were drawn last time whose status is probably different
     * now. Used to cause changed states to flash blue on screen.
     * 
     * statesChanged: States whose status has changed in the planner.
     * 
     * statesOpened: States placed on open queue
     * 
     * statesClosed: States placed in closed set
     * 
     * statesMarked. States placed in this set for general debugging purposes. The semantics
     * are up to the programmer.
     * 
     * With the exception of statesMarked, states are rendered based on their internal flags
     * rather than membership in these sets. Hence, only the first (for transient coloring) and 
     * the last (for general use) of these sets are strictly necessary. The rest could
     * be placed in a single set. 
     * 
     * State sets really are sets so a state cannot appear twice in any set. On the other hand,
     * no attempt is made (or needed) to make sure a state is not in more than one set. Priority
     * order rendering is used to resolve such ambiguity.
     * 
     * 									Comments on Changes
     * 
     * There are two types of changes that we would like to draw on screen: Cost map
     * and search tree. Cost map changes can happen either because the user has modified
     * the obstacles or because perception has seen more obstacles. Cost map changes
     * are drawn by simply rerendering the cost map. 
     * 
     * Once cost map changes occur, planning may update the search tree as a result. Search
     * tree rendering attempts to highlight changes by drawing changed backpointers in a different 
     * color and also by distinguishing open and closed states in what remains. Changed pixels
     * are those whose f() values have changed (not the cell traversal costs but total costs) or
     * whose backpointer has changed. For ease in visualising changes that result from added and
     * deleted obstacles, change detection is measured ACROSS queries in Grassfire, Astar and 
     * Dstar. By contrast, change detection is measured across incremental updates in Dstar.
     *
     */
    void drawSearchTree(){
    	if(!doHorizonDrawing) return;
    	/**
    	 * Thisloop changes attributes of graphical objects which may be in the process of
    	 * getting drawn in the java GUI thread. Hence it synchronizes on the display list. The
    	 * graphics thread does the same thing so only one of the two will operate at a time.
    	 */
		synchronized(appWorld){
			/**
			 * Transient cells are those that were drawn as changed last time. They
			 * will be redawn a second time in their normal color in this loop. The 
			 * effect if for them to flash on screen right after they are changed.
			 * This effect depends on the changed flag being turned off by the time they
			 * are rendered a second time. This means recordCosts should be called after this 
			 * routine is called to make sure the changed flag is cleared.
			 */
			for(MotionPlannerState state: motionPlannerContext.statesTransient) {
				updateArrowSprite(state,false);
			}
			motionPlannerContext.statesTransient.clear();
			
			/**
			 * Changed states have had their cost or their parent or both changed. 
			 */
			for(MotionPlannerState state: motionPlannerContext.statesChanged) {
				updateArrowSprite(state,false);
				//state.saveLastCostInfo();
				motionPlannerContext.statesTransient.add(state);
			}
			motionPlannerContext.statesChanged.clear();
			
			/**
			 * Opened states were just opened.
			 */
			for(MotionPlannerState state: motionPlannerContext.statesOpened) {
		    	Sprite sprite = arrowSprites.getCellValueField(new Point2D.Double(state.x(),state.y()));
				sprite.userData = state;
				state.userData = sprite;
				updateArrowSprite(state,false);
			}
			motionPlannerContext.statesOpened.clear();
			
			/**
			 * Closed states were moved from open to closed.
			 */
			for(MotionPlannerState state: motionPlannerContext.statesClosed) {
				updateArrowSprite(state,false);
			}
			motionPlannerContext.statesClosed.clear();
			
			/**
			 * The marked array is for debugging. If you want the marks to be transient (shown
			 * once), uncomment the addition to statesTransient.
			 */
			for(MotionPlannerState state: motionPlannerContext.statesMarked) {
				updateArrowSprite(state,true);
				//motionPlanner.motionPlannerContext.statesTransient.add(state);
			}
			motionPlannerContext.statesMarked.clear();
		}		
		searchTreeRenderTime = System.currentTimeMillis();
    }
    
    /**
     * The attributes of states are drawn in priority order. So, a state which is both open and 
     * changed will be drawn as open, for example.
     * @param state the state whose arrow is to be drawn
     * @param marked a flag to indicate it was in the marked set
     */
    void updateArrowSprite(MotionPlannerState state, boolean marked){
		Sprite sprite = (Sprite) state.userData;
		if(sprite == null) return;
		if(marked){
			sprite.drawingContext().setBorderColor(markedColor);
			sprite.drawingContext().setDoDrawBorder(true);
		} else if(state.open){
			sprite.drawingContext().setBorderColor(openColor); 
			sprite.drawingContext().setDoDrawBorder(true);
		} else if(state.hasChanged()){
				sprite.drawingContext().setBorderColor(changedColor);
				sprite.drawingContext().setDoDrawBorder(true);
				sprite.drawingContext().setStroke(new BasicStroke((float)(0.01)));
		} else{ // state is closed if it is not open
				sprite.drawingContext().setBorderColor(closedColor);
				sprite.drawingContext().setDoDrawBorder(true);
				sprite.drawingContext().setStroke(new BasicStroke((float)(0.01)));
		}
		updateArrowHeading(state,sprite);
    }
    
    /**
     * Make sure the arrow sprite is pointing to its parent state.
     * @param state the state associated with the arrow sprite.
     * @param sprite the arrow sprite.
     */
    void updateArrowHeading(MotionPlannerState state,Sprite sprite){
		double xCen,yCen;
		xCen = state.x();
		yCen = state.y();
		if(state.getBackPointer() != null){
			sprite.poseContext().setPoseRelative(xCen,yCen,state.getBackPointerOrientation());
		} else { // start state
			sprite.drawingContext().setBorderColor(Color.YELLOW);  
			sprite.drawingContext().setDoDrawBorder(true);
			sprite.poseContext().setPoseRelative(xCen,yCen,0.0);
			sprite.drawingContext().setBorderAlpha(0.25); // make it almost see thru
		}
		
		if(drawNodeCosts) updateNodeCostPixel(state);
    }
    /**
     * Color the cost map based on the g() value of the planning tree 
     * node.
     * @param state the state associated with the arrow sprite.
     */
    void updateNodeCostPixel(MotionPlannerState state){
		double xCen,yCen;
		xCen = state.x();
		yCen = state.y();
		
		Color color;
		double poten = state.getMinG_Rhs();
		double maxPot = (motionPlannerContext.searchGraph.rows +
						 motionPlannerContext.searchGraph.cols) *
						costMap.freeCost() * 20.0;
		
		if(poten >= MotionPlannerState.Infinity) 
			color = Color.red;
		else{
			float grey = (float) (poten / maxPot);
			if(grey > 1.0)
				grey = 1.0f;
			color = new Color(grey,grey,grey);
		}
		// World coords of state
		Point2D worldPoint = new Point2D.Double(xCen,yCen);		
		// State array coords of state
		Point2D ptCell = costMap.costArray.inRectToOutRect(worldPoint);
		int j = (int) ptCell.getX();
		int i = (int) ptCell.getY();
		
		costImage.setColorPixel(i, j, color);
    }
    /**
     * Change the color of a cost cell in the cost map image.
     * @param row coordinate in cost map
     * @param col coordinate in cost map
     */
    void updateCostCellPixel(int row, int col){   
    	if(!doCostMapDrawing) return;
    	if(drawNodeCosts) return;
		
		Point2D fieldPoint = costMap.costArray.outRectToInRect(new Point2D.Double(row+0.5,col+0.5));				
		Double cost = (Double) costMap.getCellCost(fieldPoint);
		
		//System.out.printf("Cost: %f\n",cost);
		
		float grey = (float) (cost / costMap.maxCost());	
		
		Color color = new Color(grey,grey,grey);
		costImage.setColorPixel(col, row, color);
		
    }
    
    /**
     * Make sure the search tree is on screen long enough to see it.
     */
	void holdSearchTree(){
    	if(!doHorizonDrawing) return;
		double timeOnScreen = System.currentTimeMillis() - searchTreeRenderTime;
		if(timeOnScreen < searchTreeDisplayTimeInMillis){
//			 give it time to appear
			Sleeper.sleep((int)(searchTreeDisplayTimeInMillis-timeOnScreen)); 
		}
	}
	/**
	 * Erase the search tree from the display. Used to avoid clutter when the path
	 * is executing on screen.
	 *
	 */
	void eraseSearchTree(){
    	if(!doHorizonDrawing) return;
		int worldIndex=0;
		synchronized(appWorld) {
    		while(worldIndex < appWorld.size()){
    			Systm sys = appWorld.get(worldIndex);
				Drawable drawable = (Drawable) sys;
    			if(sys.name.equals("SearchElement")){  // undraw field elements
    				drawable.drawingContext().setDoDrawBorder(false);
    				worldIndex++;
    			} else {
    				worldIndex++;
    			}
    		}   
		}
	}
	/**
	 * Removes the path from the display. Used right before a new one is drawn.
	 *
	 */
	void eraseOldPath(){
		if(!doPathDrawing) return;
		int worldIndex=0;
		synchronized(appWorld) {
    		while(worldIndex < appWorld.size()){
    			Systm sys = appWorld.get(worldIndex);
    			if(sys.name.equals("PathElementRect")){ //delete path elements
    				appWorld.remove(worldIndex); // don't increment worldIndex
    			} else {
    				worldIndex++;
    			}
    		}   
		}
	}
	
	/**
	 * Draw the path
	 *
	 */
	void drawPath(){
		if(!doPathDrawing) return;
		int pathIndex=pathExecutionStateSkips; // start at first step on path
		// Draw the path
		
		ArrayList<MotionPlannerState> path = motionPlannerContext.motionPlanner.getPath();
		synchronized(appWorld) {
    		while(path != null && pathIndex < path.size()){
    			MotionPlannerState state = path.get(pathIndex);
    			Sprite rect = Sprite.RectangleSprite("PathElementRect",USER_DS,USER_DS,state.x(),state.y(),0.0);
    			rect.drawingContext().setFillColor(pathColor,0.75);
    			appWorld.add(rect);
    			pathIndex++;
    		}
		}
		simDrawingPanel.repaint();
	}
	
	/**
	 * Draw the robot in both windows.
	 * @param state state at which the robot is to be positioned.
	 */
	void drawRobot(MotionPlannerState state){
		setRobotPose(new Pose2D(state.x(),state.y(),0.0));
		drawRobot();
	}
	/**
	 * Draw the robot in both windows
	 *
	 */
	void drawRobot(){
		// Make sure robot sprite is drawn last
		simWorld.moveToTop(robotSprite);
		simWorld.moveToTop(startSprite);
		appWorld.moveToTop(robotCSpaceSprite);
		
		robotSprite.drawingContext().setDoDrawBorder(true);
		robotSprite.drawingContext().setDoDrawFill(true);
		
		robotCSpaceSprite.drawingContext().setDoDrawBorder(true);
		robotCSpaceSprite.drawingContext().setDoDrawFill(true);
	}
	/**
	 * Rease the robot from both windows.
	 *
	 */
	void eraseRobot(){
		robotSprite.drawingContext().setDoDrawBorder(false);	
		robotCSpaceSprite.drawingContext().setDoDrawBorder(false);
	}
	
	/*
	 ************************************** Control Panel ************************************
	 */
	private JRadioButton grassfireButton,
						 DykstrasButton,
						 AstarButton,
						 DstarButton;
	
    private JTextField 	USER_DS_Field,
    					maxExpansionsField,
    					minExpansionsField,
    					greedyFactorField,
    					OBS_COST_Field;
    
    private JLabel		minExpansionsLabel,
    					maxExpansionsLabel,
    					USER_DS_Label,
    					greedyFactorLabel,
    					OBS_COST_Label;
    
    private JButton		runButton,
    					pauseButton,
    					resetButton;
    
    private JCheckBox   makeRandomWorldCheckBox,
    					doNavFunctionCheckBox,
    					do8ConnectedTopologyCheckBox,
    					doManhattanMetricCheckBox,
    					executePlanCheckBox,
    					doCostMapDrawingCheckBox,
    					doReverseDstarCheckBox;
    
    private InstructionPanel   instructionPanel;
    
    private void makeControlPanel() {
    	
    	//controlPanel.setLayout(new FlowLayout(FlowLayout.RIGHT));
    	controlPanel.setLayout(new GridBagLayout());
    	
    	// Set up main algorithm switch
    	grassfireButton = new JRadioButton("Grassfire");
    	DykstrasButton = new JRadioButton("Dykstras");
    	AstarButton = new JRadioButton("Astar");
    	DstarButton = new JRadioButton("Dstar");

    	grassfireButton.addActionListener(this);
    	DykstrasButton.addActionListener(this);
    	AstarButton.addActionListener(this);
    	DstarButton.addActionListener(this);
    	
    	// Set the right radio button
		if(algorithm == Grassfire){
			grassfireButton.setSelected(true);
		} else if(algorithm == Dykstra){
			DykstrasButton.setSelected(true);
		} else if(algorithm == Astar){
			AstarButton.setSelected(true);
		} else if(algorithm == Dstar){
			DstarButton.setSelected(true);
		}

        // Group the radio buttons.
        ButtonGroup group = new ButtonGroup();
        group.add(grassfireButton);
        group.add(DykstrasButton);
        group.add(AstarButton);
        group.add(DstarButton);
        
        // Put the radio buttons in two columns in a panel
        ControlPanelBasic radioPanel = new ControlPanelBasic(PANEL_SIZE/5,PANEL_SIZE/2,"Algorithm");
        radioPanel.setLayout(new GridLayout(0, 2));
        radioPanel.add(grassfireButton);
        radioPanel.add(DykstrasButton);
        radioPanel.add(AstarButton);
        radioPanel.add(DstarButton);
        controlPanel.add(radioPanel);
        
    	// maxExpansions field
    	maxExpansionsLabel = new JLabel("maxExpansions:");
    	maxExpansionsField = new JTextField(String.valueOf(maxExpansions),2);
    	maxExpansionsField.setColumns(3);
    	
    	// minExpansions field
    	minExpansionsLabel = new JLabel("minExpansions:");
    	minExpansionsField = new JTextField(String.valueOf(minExpansions),2);
    	
    	// greedyFactor field
    	greedyFactorLabel = new JLabel("greedyFactor:");
    	greedyFactorField = new JTextField(String.format("%6.3f",greedyFactor),2);
	
    	// USER_DS field
    	USER_DS_Label = new JLabel("USER_DS:");
    	USER_DS_Field = new JTextField(String.format("%6.3f",USER_DS),2);
    	
    	// OBS_COST field
    	OBS_COST_Label = new JLabel("OBS_COST:");
    	OBS_COST_Field = new JTextField(String.format("%6.3f",OBS_COST),2);
    	
    	// Put the fields in two columns in a panel
        ControlPanelBasic fieldPanel = new ControlPanelBasic(PANEL_SIZE/5,PANEL_SIZE/2,"Parameters");
        fieldPanel.setLayout(new GridLayout(0, 2));
        fieldPanel.add(maxExpansionsLabel); fieldPanel.add(maxExpansionsField);
        fieldPanel.add(minExpansionsLabel); fieldPanel.add(minExpansionsField);
        fieldPanel.add(greedyFactorLabel);  fieldPanel.add(greedyFactorField);
        fieldPanel.add(USER_DS_Label);      fieldPanel.add(USER_DS_Field);
        fieldPanel.add(OBS_COST_Label);     fieldPanel.add(OBS_COST_Field);
    	controlPanel.add(fieldPanel);
    	
       	//makeRandomWorld Checkbox
    	makeRandomWorldCheckBox = new JCheckBox("RandWorld",makeRandomWorld);
    	makeRandomWorldCheckBox.addActionListener(this);
       	
       	//doNavFunction Checkbox
       	doNavFunctionCheckBox = new JCheckBox("NavFunction",doNavFunction);
       	doNavFunctionCheckBox.addActionListener(this);
       	
       	//do8ConnectedTopology Checkbox
       	do8ConnectedTopologyCheckBox = new JCheckBox("8Connected",do8ConnectedTopology);
       	do8ConnectedTopologyCheckBox.addActionListener(this);
       	
       	//doManhattanMetric Checkbox
       	doManhattanMetricCheckBox = new JCheckBox("Manhattan",doManhattanMetric);
       	doManhattanMetricCheckBox.addActionListener(this);
       	
       	//Execution Checkbox
    	executePlanCheckBox = new JCheckBox("ExecutePlan",executePlan);
    	executePlanCheckBox.addActionListener(this);
       	
       	//doCostMapDrawing Checkbox
       	doCostMapDrawingCheckBox = new JCheckBox("CostMapDrw",doCostMapDrawing);
       	doCostMapDrawingCheckBox.addActionListener(this);
       	
       	//doReverseDstar Checkbox
       	doReverseDstarCheckBox = new JCheckBox("ReverseD*",doReverseDstar);
       	doReverseDstarCheckBox.addActionListener(this);
       	
    	// Put the booleans in one columns in a panel
        ControlPanelBasic flagPanel = new ControlPanelBasic(PANEL_SIZE/5,PANEL_SIZE/2,"Flags");
        flagPanel.setLayout(new GridLayout(0, 2));
        flagPanel.add(makeRandomWorldCheckBox);
        flagPanel.add(doNavFunctionCheckBox);
        flagPanel.add(do8ConnectedTopologyCheckBox);
        flagPanel.add(doManhattanMetricCheckBox);
        flagPanel.add(executePlanCheckBox);
        flagPanel.add(doCostMapDrawingCheckBox);
        flagPanel.add(doReverseDstarCheckBox);
    	controlPanel.add(flagPanel);
    	
    	// Run Button
    	runButton = new JButton("Run");
    	runButton.addActionListener(this);
       	
       	// Pause Button
       	pauseButton = new JButton("Pause");
    	pauseButton.addActionListener(this);
       	
       	// Reset Button
       	resetButton = new JButton("Reset");
    	resetButton.addActionListener(this);
       	
    	// Put the main buttons in one rows in a panel
        ControlPanelBasic buttonPanel = new ControlPanelBasic(PANEL_SIZE/10,PANEL_SIZE/8,"Program Control");
        buttonPanel.setLayout(new GridLayout(1, 3));
        buttonPanel.add(runButton);
        buttonPanel.add(pauseButton);
        buttonPanel.add(resetButton);
    	controlPanel.add(buttonPanel);
        
       	// Instruction Text
       	instructionPanel = new InstructionPanel("applications/homeworks/ApplicationHW1MotionPlanner.txt",300,200);
       	parentJFrame.add(instructionPanel,new GBConstraints(0,3,1,1));
    }
	/*
	 ******************************* Control Panel Event Handlers *****************************
	 */
    public void actionPerformed(ActionEvent e){
    	
    	Object source = e.getSource();
    	
    	if(source == runButton){
    		iAmActive = true;
    		runButton.setSelected(true);
    		pauseButton.setSelected(false);
    		System.out.printf("Starting\n");
    	} else if(source == pauseButton){
    		System.out.printf("Stopping\n");
    		runButton.setSelected(false);
    		pauseButton.setSelected(true);
    		iAmActive = false;
		} else if(source == resetButton){
			if(iAmActive){
				System.out.printf("You must stop First\n");
				return;
			}
			// Read state of algorithm
			
			if(grassfireButton.isSelected()){
				System.out.printf("Doing Grassfire\n");
				algorithm = Grassfire;
			} else if(DykstrasButton.isSelected()){
	    		System.out.printf("Doing Dykstras\n");
	    		algorithm = Dykstra;
			} else if(AstarButton.isSelected()){
	    		System.out.printf("Doing Astar\n");
	    		algorithm = Astar;
			} else if(DstarButton.isSelected()){
	    		System.out.printf("Doing Dstar\n");
	    		algorithm = Dstar;
			}
			
			// Read state of parameters
			USER_DS = Double.parseDouble(USER_DS_Field.getText());
			System.out.printf("New USER_DS is %f\n",USER_DS);
			OBS_COST = Double.parseDouble(OBS_COST_Field.getText());
			System.out.printf("New OBS_COST is %f\n",OBS_COST);
			greedyFactor = Double.parseDouble(greedyFactorField.getText());
			System.out.printf("New greedyFactor is %f\n",greedyFactor);
			maxExpansions = Integer.parseInt(maxExpansionsField.getText());
			System.out.printf("New maxExpansions is %d\n",maxExpansions);
			minExpansions = Integer.parseInt(minExpansionsField.getText());
			System.out.printf("New minExpansions is %d\n",minExpansions);
			// Read state of Flags
			if(makeRandomWorldCheckBox.isSelected()) makeRandomWorld = true;
			else makeRandomWorld = false;
			System.out.printf("New makeRandomWorld is %b\n",makeRandomWorld);
			if(doNavFunctionCheckBox.isSelected()) doNavFunction = true;
			else doNavFunction = false;
			System.out.printf("New doNavFunction is %b\n",doNavFunction);
			if(do8ConnectedTopologyCheckBox.isSelected()) do8ConnectedTopology = true;
			else do8ConnectedTopology = false;
			System.out.printf("New do8ConnectedTopology is %b\n",do8ConnectedTopology);
			if(doManhattanMetricCheckBox.isSelected()) doManhattanMetric = true;
			else doManhattanMetric = false;
			System.out.printf("New doManhattanMetric is %b\n",doManhattanMetric);
			if(executePlanCheckBox.isSelected()) executePlan = true;
			else executePlan = false;
			System.out.printf("New executePlan is %b\n",executePlan);
			if(doCostMapDrawingCheckBox.isSelected()) doCostMapDrawing = true;
			else doCostMapDrawing = false;
			System.out.printf("New doCostMapDrawing is %b\n",doCostMapDrawing);
			if(doReverseDstarCheckBox.isSelected()) doReverseDstar = true;
			else doReverseDstar = false;
			System.out.printf("New doCostMapDrawing is %b\n",doCostMapDrawing);
			
			iAmActive = false;
			
			stop();
			startOrReset();
    		
		} else if(source == grassfireButton){
    		System.out.printf("Doing Grassfire\n");
    		algorithm = Grassfire;
    		
		} else if(source == DykstrasButton){
    		System.out.printf("Doing Dykstras\n");
    		algorithm = Dykstra;
    		
		} else if(source == AstarButton){
    		System.out.printf("DoingG Astar\n");
    		algorithm = Astar;
    		
		} else if(source == DstarButton){
    		System.out.printf("Doing Dstar\n");
    		algorithm = Dstar;
    		
		} else if(source == USER_DS_Field){
			USER_DS = Double.parseDouble(USER_DS_Field.getText());
			System.out.printf("New USER_DS is %f\n",USER_DS);
		} else if(source == OBS_COST_Field){
			OBS_COST = Double.parseDouble(OBS_COST_Field.getText());
			System.out.printf("New OBS_COST is %f\n",OBS_COST);
		} else if(source == greedyFactorField){
			greedyFactor = Double.parseDouble(greedyFactorField.getText());
			System.out.printf("New greedyFactor is %f\n",greedyFactor);
		} else if(source == maxExpansionsField){
			maxExpansions = Integer.parseInt(maxExpansionsField.getText());
			System.out.printf("New maxExpansions is %d\n",maxExpansions);
		} else if(source == minExpansionsField){
			minExpansions = Integer.parseInt(minExpansionsField.getText());
			System.out.printf("New minExpansions is %d\n",minExpansions);			
		} else if(source == makeRandomWorldCheckBox){
			if(makeRandomWorldCheckBox.isSelected()) makeRandomWorld = true;
			else makeRandomWorld = false;
			System.out.printf("New makeRandomWorld is %b\n",makeRandomWorld);
		} else if(source == doNavFunctionCheckBox){
			if(doNavFunctionCheckBox.isSelected()) doNavFunction = true;
			else doNavFunction = false;
			System.out.printf("New doNavFunction is %b\n",doNavFunction);
		} else if(source == do8ConnectedTopologyCheckBox){
			if(do8ConnectedTopologyCheckBox.isSelected()) do8ConnectedTopology = true;
			else do8ConnectedTopology = false;
			System.out.printf("New do8ConnectedTopology is %b\n",do8ConnectedTopology);
		} else if(source == doManhattanMetricCheckBox){
			if(doManhattanMetricCheckBox.isSelected()) doManhattanMetric = true;
			else doManhattanMetric = false;
			System.out.printf("New doManhattanMetric is %b\n",doManhattanMetric);
		} else if(source == executePlanCheckBox){
			if(executePlanCheckBox.isSelected()) executePlan = true;
			else executePlan = false;
			System.out.printf("New executePlan is %b\n",executePlan);
		} else if(source == doCostMapDrawingCheckBox){
			if(doCostMapDrawingCheckBox.isSelected()) doCostMapDrawing = true;
			else doCostMapDrawing = false;
			System.out.printf("New doCostMapDrawing is %b\n",doCostMapDrawing);
		} else if(source == doReverseDstarCheckBox){
			if(doReverseDstarCheckBox.isSelected()) doReverseDstar = true;
			else doReverseDstar = false;
			System.out.printf("New doReverseDstar is %b\n",doReverseDstar);
		}
    	
    }
    
    //====================Drawing Area Events =============================//
    
    public void rectangleDrawn(Sprite rect){
    	
    }
    
    public void pathDrawn(Sprite path){
    	
    }
    
    public void clickDrawn(MouseEvent e, Point2D userPt){ 
    	int button = e.getButton();
    	if(button == 1) handleLeftDown(userPt);
    	else if(button == 3) handleRightDown(userPt);
    }
    
    public DrawingAreaEventConsolidator.EntryMode getEntryMode(){
    	return EntryMode.Point;
    }
    
    private void handleLeftDown(Point2D userPoint){
    	MotionPlannerState state = motionPlannerContext.searchGraph.peekState(userPoint);
    	if(state != null)System.out.println(state);

    }
    
    private void handleRightDown(Point2D userPoint){
    }
}