package applications.homeworks.unlocked.hw1;

import java.lang.annotation.*; // import this to use @Documented
import java.util.*;
import java.awt.*;
import java.awt.geom.*;

import smrde.Systm;
import smrde.math.*;
import smrde.systems.*;


/**
 * A cost map for use in motion planning. This class uses RectangleMap to
 * establish a mapping between a continuous rectangular region in space and an array 
 * of discrete cells containing cost information. A cost of traversal is associated 
 * with each cell in the map. In the cost map array, the mapping of space onto array
 * coordinates is determined by the conventions of RectangleMapField. 
 * 
 * That is, the rows (i) of the map are aligned with the u(x) coordinate of the viewport 
 * and the columns (j) are aligned with the v(y) coordinate, so the point (i,j) corresponds 
 * to the point (u,v).
 * 
 * A list of obstacle polygons is provided in the constructor and thereafter any cell 
 * is considered an obstacle cell when the robot, when placed at its center, intersects one 
 * of the those obstacle polygons. Methods are provided to react to changes in the obstacle 
 * list to enable real-time modification of the environment by the user.
 * 
 * While the cost map always contains all obstacle information, it may not be visible to the 
 * application. When the value in a cell is read it is only visible if it has been seen before
 * (hence perception memory is implemented here rather than in perception) or if it is within 
 * the maximum sensor radius from the current position. Because the map is completely known 
 * underneath this mechanism, there is no significant cost incurred here to update the cost map 
 * as the robot moves. A motion planner, however, will undoubtedly want to update its search 
 * tree as more cells become visible.
 * 
 * @author alonzo
 *
 */
public class MotionPlannerCostMap{
	
	static final long serialVersionUID = 1L;
	
	/**
	 * Spatial resolution of coordinates.
	 */
	private Forceable body;
	/**
	 * List of obstacles to incorporate into the cost map
	 */
	private World     worldList;
	/**
	 *  The cost map (spatial array of cost cells).
	 */
	public RectangleMapField<Double>  costArray;
	/**
	 * A spatial arry of flags used to implement simulated sensing.
	 */
	public RectangleMapField<Boolean> flagArray;
	/**
	 * Cost of an obstacle cell. This is generally higher than free but interesting effects
	 * can be generated by making is less than the freeCost.
	 */
	private double obsCost = 1000.0;
	/**
	 * Cost of an empty cell.
	 */
	private double freeCost = 1.0;
	/**
	 * Default cost of a cell.
	 */
	private double defaultCost = freeCost;
	/**
	 * Reference to (dynamically updated) pose of sensor in world
	 */
	private Pose2D sensorPose;
	/**
	 * Maximum range of sensor.
	 */
	private double sensorRadius;
	/**
	 * List of cells modified by addition and deletion of obstacles.
	 */
	public LinkedHashSet<Point2D> cellsModified = new LinkedHashSet<Point2D>();
	/**
	 * List of cells seen by sensor
	 */
	public LinkedHashSet<Point2D> cellsSeen = new LinkedHashSet<Point2D>();
	/**
	 * Switch for debug graphics. Draws  on screen a box (expanded by robot radius) around 
	 * the last obstacle processed.
	 */
	boolean doDebugGraphics = false;
	/**
	 * A rectangle used for debugging.
	 */
	Sprite debugRectangleSprite;
	
	/**
	 * Constructs a MotionPlannerCostMap
	 * @param body the object that will be intersected with obstacles to determine collisions.
	 * @param sensorPose pose of the sensor in WORLD frame
	 * @param sensorRadius radius beyond wheich sensor cannot see
	 * @param worldList list of polygonal obstacles
	 * @param worldRect the entire region with which paths and obstacles must reside
	 * @param obsCost the cost of an obstacle cell
	 * @param resolution the length of the side of the square cells
	 */
	public MotionPlannerCostMap(Forceable body, Pose2D sensorPose, double sensorRadius, 
			World worldList, Rectangle2D worldRect, double obsCost, double resolution){
		
		costArray = new RectangleMapField<Double>(worldRect,resolution);
		flagArray = new RectangleMapField<Boolean>(worldRect,resolution);
		
		this.body = body;
		this.sensorPose = sensorPose;
		this.sensorRadius = sensorRadius;
		this.worldList = worldList;
		this.obsCost   = obsCost;
		
		if(doDebugGraphics){			
			debugRectangleSprite  = Sprite.RectangleSprite("Obstacle Bbox", 1.0, 1.0, 0.0, 0.0, 0.0);
			debugRectangleSprite.drawingContext().setBorderColor(Color.red);
			worldList.add(debugRectangleSprite);
		}
		
		initializeCostMap();
	}
	
	/**
	 * Process the supplied obstacle list to produce the initial cost map.
	 */
	private void initializeCostMap(){
		
		costArray.initializeAllFields(freeCost);
		flagArray.initializeAllFields(false);
		
		for(Systm sys: worldList){
			if (sys instanceof RigidBodySprite){
				processObstacle((RigidBodySprite)sys,true);
			}
		}
	}
	
	/**
	 * Get the cost of an empty cell.
	 * @return the cost of an empty cell.
	 */
	public double freeCost(){
		return freeCost;
	}
	/**
	 * Get the cost of an obstacle cell.
	 * @return the cost of an obstacle cell.
	 */
	public double obsCost(){
		return obsCost;
	}
	/**
	 * Maximum cost of any cell. Used for graphics normalization.
	 * @return maximum cost of any cell
	 */
	public double maxCost(){ 
		return Math.max(obsCost, freeCost);
	}
	/**
	 * Gets the cost of the cell at the indicated position. Artificially
	 * restricts access to cost information beyond the maximum sensor radius.
	 * @param pt point where cost is desired
	 * @return the cost of the cell 
	 */
	public double getCellCost(Point2D pt){
		double cost = costArray.getCellValueField(pt);
		double dist = Math.hypot(sensorPose.getX()-pt.getX(),sensorPose.getY()-pt.getY());
		// If it is remembered, return it
		if(flagArray.getCellValueField(pt)){
			return cost;
		// If not remembered but within range, read it, and mark it as remembered
		} else if(dist < sensorRadius){
			cellsSeen.add(pt);
			flagArray.setCellValueField(pt, true); // mark cell as seen so it is remembered
			return cost;
			// If out of range return default cost
		}  else {
			return defaultCost;
		}
	}
	
	/**
	 * Sets the cost of the cell at the indicated position.
	 * @param pt point where cost is to be set
	 * @param cost the cost value to set it to
	 */
	public void setCellCost(Point2D pt, double cost){		
		// Costs of zero indicate the cell is empty. Nonzero means a change
		// is occurring since it was initially set.
		double oldCost = (Double) costArray.getCellValueField(pt);
		
		if(oldCost != 0.0){
			cellsModified.add(pt);
		}
		// set the cost
		costArray.setCellValueField(pt,cost);
	}

	/*
	 *********************** Process Obstacles / Cost Updates *********************
	 */	
	
	/**
	 * Process the lists of added a deleted obstacles to update the cost map.
	 * @param addedObstacles the list of obstacles that were added since last time
	 * @param deletedObstacles the list of obstacles that were deleted since last time
	 */
	public void processObstacles(ArrayList<RigidBodySprite> addedObstacles,
			ArrayList<RigidBodySprite> deletedObstacles){
		if(addedObstacles != null) {
			for(RigidBodySprite obs: addedObstacles){
				processObstacle(obs,true);
			}
		}
		if(deletedObstacles != null) {
			for(RigidBodySprite obs: deletedObstacles){
				processObstacle(obs,false);
			}
		}
	}
	/**
	 * Process a single obstacle by adding or deleting cost in the cost map depending on 
	 * whether the obstacle was added or deleted.
	 * @param obstacle the obstacle to process
	 * @param added true if added, false if deleted
	 */
	private void processObstacle(RigidBodySprite obstacle,boolean added){
		
		// Get the bounding box for the obstacle
		Rectangle2D rect = obstacle.shapeContext().worldCoordinateBoundingRectangle();
		
		// Find the radius of the circle that contains the entire body
		double radius = body.shapeContext().shapeMaxRadius(costArray.getDx()/100.0);
		//radius += costArray.getDx(); // extra margin to avoid collision
		
		// Increase the size of the bounding box by the body radius. This is a form
		// of Configuration Space expansion.
		rect.setRect(rect.getX()-radius,rect.getY()-radius,rect.getWidth()+radius*2.0,rect.getHeight()+radius*2.0);
		
		// Draw the overall bbox
		if(doDebugGraphics){ debugRectangleSprite.shapeContext().setShape(rect);}
		
		// Get the list of cells in this rectangle
		ArrayList<Point2D> cellList = costArray.getCellsInUserRectangle(rect);
		
		for(Point2D pt: cellList){
			boolean collision = isInCollision(pt);
			if(added && collision){
				setCellCost(pt,obsCost);	
			} else if (!added && !collision) {
				setCellCost(pt,freeCost);	
			}
		}
	}
	
	/**
	 * Tests if the body is in collision at the indicated pose.
	 * @param pt the position of the state to be tested
	 * @return true if the body intersects any obstacles
	 */
	public boolean isInCollision(Point2D pt){		
		boolean collision;
		Pose2D queryPose = new Pose2D(pt.getX(),pt.getY(),0.0);
		body.poseContext().setPoseWorld(queryPose);
		synchronized(worldList){
			collision = InertialContext.doesOverlapForceable(body,worldList);
		}
		
//		monitorPosition(-0.38,-3.875,pt, collision);
		
		return(collision);
	}
	
	/**
	 * Monitor a particular position to see what happens when it is checked.
	 * @param x x coord of point to monitor
	 * @param y y coord of point to monitor
	 * @param pt point being checked
	 * @param collision
	 */
	@SuppressWarnings("unused")
	private void monitorPosition(double x, double y, Point2D pt, boolean collision){
		double dx = x - pt.getX();
		double dy = y - pt.getY();
		double radius = Math.hypot(dx,dy);
		if(radius < costArray.getDx()){
			System.out.printf("Checking %f %f %b\n",pt.getX(),pt.getY(), collision);
		}
	}
	
	/**
	 * Tests if the body is in collision at the indicated pose and updates
	 * the associated cell.
	 * @param pt the position of the state to be tested
	 * @return true if the body intersects any obstacles
	 */
	public boolean checkPointForCollision(Point2D pt){
		boolean collision = isInCollision(pt);
		if(collision){
			//System.out.printf("Obstacle\n");
			setCellCost(pt,obsCost);
		}
		else
			setCellCost(pt,freeCost);
		return(collision);
	}
}

